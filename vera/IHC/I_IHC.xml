<?xml version="1.0"?><implementation>  <settings>    <protocol>crnl</protocol>  </settings>  <functions>local IHC_SERVICE = "urn:upnp-gabelgaard-org:serviceId:ihc1"    startupReady = 0    startTime = 0    endTime = 0    buffer = ""    IHCmsgTable = {}    IHCLastMsg = ""    ipAddress = ""    ipPort = 0    		  function mainStartup(lul_device)        IHCDevices = {}		IHCDevicesLS = {}		IHCDevicesLSname = {}		IHCCountLS = 0		IHCDevicesDS = {}		IHCDevicesDSname = {}		IHCCountDS = 0				THIS_DEVICE = lul_device		luup.log("Starting IHC device: " .. tostring(THIS_DEVICE))		local device = luup.devices[THIS_DEVICE]		-- Set our device IP number		if (device.ip == "") then			return false, "IP Address attribute must be configured", "ihc"		end		ipAddress = device.ip		-- Get defined read and write port. If not set, set the default port numbers 10001 and 10002		local portList = luup.variable_get("urn:upnp-gabelgaard-org:serviceId:ihc1", "port", lul_device)		if ((portList or "") == "") then			portList = "10994"			luup.variable_set("urn:upnp-gabelgaard-org:serviceId:ihc1", "port", portList, lul_device)		elseif (portList:find("%d") == nil) then			return false, "The Port Read parameter must be of the form nnnn.  eg. 10001"		end		ipPort = portList	  				-- Check if we should create the devices automaticly		local IHCAutoCreate = luup.variable_get("urn:upnp-gabelgaard-org:serviceId:ihc1", "AutoCreate", lul_device)		if ((IHCAutoCreate or "") == "") then			luup.variable_set("urn:upnp-gabelgaard-org:serviceId:ihc1", "AutoCreate", "0", lul_device)		end				-- Check all devices if they are childeren. If so, register in		-- the correct array based on the device type		for k, v in pairs(luup.devices) do			-- Look for devices with this device as parent			if (v.device_num_parent == lul_device) then				luup.log( "Found child device, lets save! id " .. tostring(v.id) .. " device " .. tostring(v.device_type))								-- Check on light switches 				if (tostring(v.device_type) == "urn:schemas-upnp-org:device:BinaryLight:1") then					IHCCountLS = IHCCountLS + 1					IHCDevicesLS[IHCCountLS] = v.id					IHCDevicesLSname[IHCCountLS] = v.description					IHCDevices[v.id] = "Switch"				end				if (tostring(v.device_type) == "urn:schemas-upnp-org:device:DimmableLight:1") then					IHCCountDS = IHCCountDS + 1					IHCDevicesDS[IHCCountDS] = v.id					IHCDevicesDSname[IHCCountDS] = v.description					IHCDevices[v.id] = "Dimmer"				end							end		end		luup.log("Tree with number child devices:")		luup.log("     light switches: " .. IHCCountLS)					luup.log("Open socket for read " .. ipAddress .. " port " .. ipPort )		luup.io.open(THIS_DEVICE, ipAddress, ipPort)		startupReady = 1		if (luup.io.write("query" .. string.char(13)) == false) then	                log("Cannot send command " .. command .. " communications error")	                luup.set_failure(true)	                return false	            end	  		luup.log("Startup IHC ready")		return true, "ok", "ihc"  end       function ToByteString( psHexString)    local resultstr = ""    if ( psHexString ~= nil ) then      for teller = 1, string.len(psHexString), 2 do        local lsHex = string.sub(psHexString, teller, teller+1)        resultstr = resultstr .. string.char( tonumber( lsHex, 16) )      end    end    return resultstr  end      function formattohex(dataBuf)    local resultstr = ""    if ( dataBuf ~= nil ) then      for teller = 1, string.len(dataBuf) do        resultstr = resultstr .. string.format("%02X ", string.byte(dataBuf, teller) )      end    end    return resultstr  end      --Helper function to get a substring that can handle null chars  function GetStringPart( psString, piStart, piLen )    local lsResult = ""    if ( psString ~= nil ) then      local liStringLength = 1 + #psString      for teller = piStart, (piStart + piLen - 1) do        -- if not beyond string length        if ( liStringLength > teller ) then          lsResult = lsResult .. string.sub(psString, teller, teller)        end      end    end    return lsResult  end	  function sendCommand(command, device, value)	            local cmd = command .. " " .. device .. " " .. value	            local startTime, endTime		            if (luup.io.write(cmd .. string.char(13)) == false) then	                luup.log("Cannot send command " .. cmd .. " communications error")	                luup.set_failure(true)	                return false	            end	           	            luup.log("Send command: " .. cmd)	            return true	        endfunction explode(d,p)  local t, ll  t={}  ll=0  if(#p == 1) then return {p} end    while true do      l=string.find(p,d,ll,true) -- find the next d in the string      if l~=nil then -- if "not not" found then..        table.insert(t, string.sub(p,ll,l-1)) -- Save it in our array.        ll=l+1 -- save just after where we found it for searching next time.      else        table.insert(t, string.sub(p,ll)) -- Save what's left in our array.        break -- Break at end, as it should be, according to the lua manual.      end    end  return tend	-- Thanks to guessed for this snippet.    function findChild(parentDevice, label)      for k, v in pairs(luup.devices) do	    	if (v.device_num_parent == parentDevice and string.find(v.id, label .. "$", 1) == 1) then		       return k    	    end      	end      end      </functions>  <incoming>    <lua>      -- When still starting up ignore any data...      if ( startupReady == 1 ) then        luup.log("Received: " .. lul_data)        if (lul_data == "deviceend") then             luup.io.write("wait" .. string.char(13))        else         	local Cmd = explode(",", lul_data)         	luup.log("Split " .. Cmd[1] .. " : " .. Cmd[2])         	if (Cmd[1] == "device") then         		-- Check if we can find a device with the decoded ID and ourself as parent				local device = findChild(THIS_DEVICE, Cmd[2] )				if device == nil and luup.variable_get("urn:upnp-gabelgaard-org:serviceId:ihc1", "AutoCreate", lul_device) == "1" then					luup.log( "device not found and autocreate enabled..." ) 								local child_devices = luup.chdev.start(THIS_DEVICE);  										------------------------------------------------------------------------------------								-- First add all 'old' children to the three					-- Next with light switches					------------------------------------------------------------------------------------								for teller = 1, IHCCountLS do			  			luup.chdev.append(THIS_DEVICE, child_devices, IHCDevicesLS[teller], "IHC Switch " .. IHCDevicesLSname[teller] , 							"urn:schemas-upnp-org:device:BinaryLight:1","D_BinaryLight1.xml","","",false)					end											-- Next with Dimmers					------------------------------------------------------------------------------------								for teller = 1, IHCCountDS do			  			luup.chdev.append(THIS_DEVICE, child_devices, IHCDevicesDS[teller], "IHC Dimmer " .. IHCDevicesDSname[teller] , 							"urn:schemas-upnp-org:device:DimmableLight:1","D_DimmableLight1.xml","","",false)					end											------------------------------------------------------------------------------------								-- Add if lightswitch					------------------------------------------------------------------------------------								if (Cmd[3] == "Switch") then						luup.log("CREATING CHILD DEVICE LIGHT SWITCH WITH ID " .. Cmd[2])						luup.chdev.append(THIS_DEVICE, child_devices, Cmd[2], "IHC Switch " .. Cmd[4] , 							"urn:schemas-upnp-org:device:BinaryLight:1","D_BinaryLight1.xml","","",false)						IHCCountLS = IHCCountLS + 1						IHCDevicesLS[IHCCountLS] = Cmd[2]						IHCDevicesLSname[IHCCountLS] = Cmd[4]						IHCDevices[Cmd[2]] = "Switch"					end										------------------------------------------------------------------------------------								-- Add if Dimmer					------------------------------------------------------------------------------------								if (Cmd[3] == "Dimmer") then						luup.log("CREATING CHILD DEVICE LIGHT SWITCH WITH ID " .. Cmd[2])						luup.chdev.append(THIS_DEVICE, child_devices, Cmd[2], "IHC Switch " .. Cmd[4] , 							"urn:schemas-upnp-org:device:DimmableLight:1","D_DimmableLight1.xml","","",false)						IHCCountDS = IHCCountDS + 1						IHCDevicesDS[IHCCountDS] = Cmd[2]						IHCDevicesLSname[IHCCountDS] = Cmd[4]						IHCDevices[Cmd[2]] = "Dimmer"					end										-- Synch the new tree with the old three					luup.log("Start sync")					luup.chdev.sync(THIS_DEVICE, child_devices)					luup.log("End sync")				end			         	elseif (Cmd[1] == "updatevalue") then         		luup.log("Updatevalue handling: " .. Cmd[2] .. Cmd[3])         		------------------------------------------------------------------------------				-- Deliver message to all devices with the correct altid (multiple				-- devices can have the correct altid!)				------------------------------------------------------------------------------						local dev = findChild(THIS_DEVICE, Cmd[2] )				if (dev ~= nil) then				    local newTargetValue = "0"				    if (Cmd[3] == "True") then				    	newTargetValue = "1"				    	luup.variable_set("urn:upnp-org:serviceId:SwitchPower1","Status",newTargetValue,dev)				    elseif (Cmd[3] == "False") then				    	newTargetValue = "0"				    	luup.variable_set("urn:upnp-org:serviceId:SwitchPower1","Status",newTargetValue,dev)				    else				    	newTargetValue = Cmd[3]					    	luup.variable_set("urn:upnp-org:serviceId:Dimming1","LoadLevelStatus",newTargetValue,dev)				    end						luup.log("SET TARGET from " .. Cmd[2] .. " with value " .. newTargetValue .. "(" .. Cmd[2]  .. "/" .. dev ..")")									end -- dev         	end -- updatevalue		        end -- Command handling          end -- Ready    </lua>  </incoming>  <startup>mainStartup</startup>	<actionList>		<action>			<serviceId>urn:upnp-org:serviceId:SwitchPower1</serviceId>			<name>SetTarget</name>			<run>				local ls_id = luup.devices[lul_device].id				local lul_reverse = luup.variable_get("urn:micasaverde-com:serviceId:HaDevice1","ReverseOnOff",lul_device)								luup.log("SET TARGET from " .. ls_id .. " with value " .. lul_settings.newTargetValue)								if ( lul_settings.newTargetValue == "1"  or (lul_settings.newTargetValue=="0" and lul_reverse=="1") ) then				    sendCommand("setvalue", ls_id, "1")				else					sendCommand("setvalue", ls_id, "0")			    end				luup.variable_set("urn:upnp-org:serviceId:SwitchPower1","Status",lul_settings.newTargetValue,lul_device)			</run>		</action>			<action>				<serviceId>urn:upnp-org:serviceId:Dimming1</serviceId>			<name>SetLoadLevelTarget</name>			<run>				local ls_id = luup.devices[lul_device].id				--local lul_reverse = luup.variable_get("urn:micasaverde-com:serviceId:HaDevice1","ReverseOnOff",lul_device)								luup.log("SET TARGET from " .. ls_id .. " with value " .. lul_settings.newLoadlevelTarget)								-- if ( lul_settings.newTargetValue == "1"  or (lul_settings.newTargetValue=="0" and lul_reverse=="1") ) then				sendCommand("setdimmer", ls_id, lul_settings.newLoadlevelTarget)				-- else				--	sendCommand("setvalue", ls_id, "0")			    --end				luup.variable_set("urn:upnp-org:serviceId:Dimming1","LoadLevelStatus",lul_settings.newLoadlevelTarget,lul_device)			</run>		</action>			</actionList></implementation>